# eBrainFuck 开发文档

### 简介

eBrainFuck 是基于 BrainFuck 的扩展语言，同时也是编译器的名字。

### 编译器介绍

编译器是基于 Node.js 编写的。

编译器分为几种模式：纯 BrainFuck 模式，硬件实现 BrainFuck 模式。

一般来说，为了避免进入错误流程，编译器会在最后加入死循环。使用命令行 `--no-deadloop` 关闭。

##### 纯 BrainFuck 模式

命令行选项：`--mode=pureBF`

其分为 8 种语句，如：

- 符号“+” 表示当前内存单元 ++
- 符号“-” 表示当前内存单元 --
- 符号“<” 表示当前内存指针 --
- 符号“>” 表示当前内存指针 ++
- 符号“[” 表示如果当前内存单元为零，则跳转至匹配的符号“]”
- 符号“]” 表示如果当前内存单元不为零，则跳转到匹配的符号“[”
- 符号“,” 表示输入当前内存单元
- 符号“.” 表示输出当前内存单元

其中，“[” 与 “]” 必须一个在前，一个在后。

Helloworld:

```
++++++++++[>+++++++>++++++++++>+++<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.
```

由于其晦涩难懂，所以并不常用。

当然，由于不是硬件完全采用的机器语言，需要产生或许更多的代码来模拟。

”[“ 与 ”]“ 为伪操作，这样的操作会生成多条指令。

##### 硬件实现 BrainFuck 模式

命令行选项：`--mode=hardBF`

其有 13 种语句，参见 [数据表](/BFT-Machine%20Datasheet.pdf) 中的相关说明。

同时，这里加入了参数机制，因此，允许加入参数作为重复次数或栈最高四位的数据。

如：
```
A(0111)+(12)
```

A 操作之外的操作如有参数，均为重复次数。

这里引入一个特殊的操作 S，S(+/- x)表示将栈顶地址设为前/后第 x 条指令。

S(x) 表示直接设置栈顶。

S操作是伪操作，这意味着这个操作对应多个指令。

同样地，重复次数超过 17 的也是伪操作，会生成 ceil(x / 17) 条指令。

Helloworld:

```
+(104).-(3).+(7)..+(3).>+(44).-(12).>+(119).-(8).+(3).-(6).>+(10)S(+5)><->+(10)<E. 
```

### 输出格式

输出文件是两个，因此需要命令行选项。

`--output1=1.bin` 程序前 512 字节。

`--output2=2.bin` 程序后 512 字节。

这两个文件应当烧写到对应的 ROM 中。